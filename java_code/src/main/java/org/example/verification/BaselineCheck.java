package org.example.verification;

import java.io.BufferedReader;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.List;

/**
 * Utility to verify that a generated CSV keeps the baseline column order and header
 * expected by the current Bayesian FES simulation results.
 * <p>
 * It performs structural checks only; it does not validate numerical values.
 * Usage: {@code java org.example.verification.BaselineCheck path/to/results.csv}
 */
public final class BaselineCheck {

    private static final String EXPECTED_HEADER = "PadID,InitialProb,Displacement,PredictedProb,CorrectedProb";
    private static final int EXPECTED_COLUMNS = 5;
    private static final String EXPECTED_TOP_HEADER = "TopPad1,TopPad2,TopPad3";

    private BaselineCheck() {
        // Utility class
    }

    public static void main(String[] args) {
        if (args.length != 1) {
            System.err.println("Usage: java org.example.verification.BaselineCheck <results_csv_path>");
            System.exit(1);
        }

        Path csvPath = Path.of(args[0]);
        try {
            CsvCheckResult result = verify(csvPath);
            if (result.passed) {
                System.out.println("[OK] CSV structure matches the expected baseline header and column order.");
            } else {
                System.out.println("[FAIL] CSV structure mismatch:\n" + String.join("\n", result.messages));
                System.exit(2);
            }
        } catch (IOException e) {
            System.err.println("[ERROR] Could not read file: " + e.getMessage());
            System.exit(3);
        }
    }

    /**
     * Verifies the CSV structure against the expected header and column count.
     *
     * @param csvPath path to the results CSV file generated by the simulation
     * @return result of the structural verification
     * @throws IOException if the file cannot be read
     */
    public static CsvCheckResult verify(Path csvPath) throws IOException {
        List<String> messages = new ArrayList<>();
        try (BufferedReader reader = Files.newBufferedReader(csvPath)) {
            String header = reader.readLine();
            if (header == null) {
                messages.add("File is empty; expected header: " + EXPECTED_HEADER);
                return new CsvCheckResult(false, messages);
            }
            if (!EXPECTED_HEADER.equals(header.trim())) {
                messages.add("Header mismatch. Expected '" + EXPECTED_HEADER + "' but found '" + header + "'.");
            }

            int lineNumber = 1;
            String line;
            while ((line = reader.readLine()) != null && !line.trim().isEmpty()) {
                lineNumber++;
                String[] parts = line.split(",", -1);
                if (parts.length != EXPECTED_COLUMNS) {
                    messages.add("Line " + lineNumber + " has " + parts.length + " columns; expected " + EXPECTED_COLUMNS + ".");
                }
            }

            if (line == null) {
                messages.add("Missing TopPad section; expected blank line followed by '" + EXPECTED_TOP_HEADER + "'.");
                return new CsvCheckResult(false, messages);
            }

            String topHeader = reader.readLine();
            if (topHeader == null || !EXPECTED_TOP_HEADER.equals(topHeader.trim())) {
                messages.add("Top pads header mismatch. Expected '" + EXPECTED_TOP_HEADER + "' but found '" + topHeader + "'.");
            }
        }

        return new CsvCheckResult(messages.isEmpty(), messages);
    }

    /**
     * Result of the structural CSV verification.
     */
    public static final class CsvCheckResult {
        public final boolean passed;
        public final List<String> messages;

        public CsvCheckResult(boolean passed, List<String> messages) {
            this.passed = passed;
            this.messages = messages;
        }
    }
}
